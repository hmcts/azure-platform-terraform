# Docs:
# https://aka.ms/yaml

trigger:
  batch: true
  branches:
    include:
    - master

resources:
  repositories:
  - repository: cnp-azuredevops-libraries
    type: github
    ref: refs/heads/master
    name: hmcts/cnp-azuredevops-libraries
    endpoint: 'hmcts'

variables:
  - name: timeoutInMinutes
    value: 60
  - name: agentPool
    value: 'ubuntu-latest'
  - name: build
    value: $(Build.BuildNumber)
  - name: businessArea
    value: cft
  - name: product
    value: cft-platform
  - name: terraformInitSubscription
    value: 04d27a32-7a07-48b3-95b8-3c8691e1a263
  - template: vars/input-variables.yaml@cnp-azuredevops-libraries
  - name: finalAction
    ${{ if and(in(variables['Build.SourceBranch'], 'refs/heads/main', 'refs/heads/master'), in(variables['Build.Reason'], 'BatchedCI', 'IndividualCI', 'PullRequest', 'Schedule'))  }}:
      value: 'apply'
    ${{ else }}:
      value: ${{ parameters.overrideAction }}
  - name: publishPlanResults
    value: false

name: "$(finalAction) - Azure Platform"

parameters:
  - name: overrideAction
    type: string
    default: plan
    values:
    - plan
    - apply
    - destroy

  - name: environment_components
    type: object
    default:
    - deployment: 'sbox_frontendappgateway'
      environment: 'sbox'
      component: 'frontendappgateway'
      service_connection: 'dcd-cftapps-sbox'
      storage_account_rg: 'core-infra-sbox-rg'
      storage_account_name: 'cftappssbox'
      dependsOn: 'Precheck'
      pipeline_tests: false

    - deployment: 'sbox_global'
      environment: 'sbox'
      component: 'global'
      service_connection: 'dcd-cftapps-sbox'
      storage_account_rg: 'core-infra-sbox-rg'
      storage_account_name: 'cftappssbox'
      dependsOn: 'Precheck'
      pipeline_tests: true

    - deployment: 'sbox_backendappgateway'
      environment: 'sbox'
      component: 'backendappgateway'
      service_connection: 'dcd-cftapps-sbox'
      storage_account_rg: 'core-infra-sbox-rg'
      storage_account_name: 'cftappssbox'
      dependsOn: 'Precheck'
      pipeline_tests: false

    - deployment: 'sbox_shutter_webapp'
      environment: 'sbox'
      component: 'shutter_static_webapp'
      service_connection: 'dcd-cftapps-sbox'
      storage_account_rg: 'core-infra-sbox-rg'
      storage_account_name: 'cftappssbox'
      dependsOn: 'Precheck'
      pipeline_tests: false

    - deployment: 'sbox_private_dns'
      environment: 'sbox'
      component: 'cftapps_private_dns'
      service_connection: 'dcd-cftapps-sbox'
      storage_account_rg: 'core-infra-sbox-rg'
      storage_account_name: 'cftappssbox'
      dependsOn: 'Precheck'
      pipeline_tests: false

    - deployment: 'sbox_apim'
      environment: 'sbox'
      component: 'apim'
      service_connection: 'dcd-cftapps-sbox'
      storage_account_rg: 'core-infra-sbox-rg'
      storage_account_name: 'cftappssbox'
      dependsOn: 'Precheck'
      pipeline_tests: true

    - deployment: 'sbox_apim_appgw'
      environment: 'sbox'
      component: 'apim-appgw'
      service_connection: 'HMCTS-HUB-SBOX-INTSVC'
      storage_account_rg: 'core-infra-sbox-rg'
      storage_account_name: 'cftappssbox'
      dependsOn: 'Precheck'
      pipeline_tests: true

    - deployment: 'dev_global'
      environment: 'dev'
      component: 'global'
      service_connection: 'dcd-cftapps-dev'
      storage_account_rg: 'core-infra-dev-rg'
      storage_account_name: 'cftappsdev'
      dependsOn: 'sbox_global'

    - deployment: 'ithc_frontendappgateway'
      environment: 'ithc'
      component: 'frontendappgateway'
      service_connection: 'dcd-cftapps-ithc'
      storage_account_rg: 'core-infra-ithc-rg'
      storage_account_name: 'cftappsithc'
      dependsOn: 'sbox_frontendappgateway'
      pipeline_tests: true

    - deployment: 'ithc_pubsubappgateway'
      environment: 'ithc'
      component: 'pubsubappgateway'
      service_connection: 'dcd-cftapps-ithc'
      storage_account_rg: 'core-infra-ithc-rg'
      storage_account_name: 'cftappsithc'
      dependsOn: 'sbox_frontendappgateway'
      pipeline_tests: true

    - deployment: 'ithc_backendappgateway'
      environment: 'ithc'
      component: 'backendappgateway'
      service_connection: 'dcd-cftapps-ithc'
      storage_account_rg: 'core-infra-ithc-rg'
      storage_account_name: 'cftappsithc'
      dependsOn: 'sbox_backendappgateway'
      pipeline_tests: true

    - deployment: 'ithc_global'
      environment: 'ithc'
      component: 'global'
      service_connection: 'dcd-cftapps-ithc'
      storage_account_rg: 'core-infra-ithc-rg'
      storage_account_name: 'cftappsithc'
      pipeline_tests: true
      dependsOn: 'sbox_global'

    - deployment: 'ithc_private_dns'
      environment: 'ithc'
      component: 'cftapps_private_dns'
      service_connection: 'dcd-cftapps-ithc'
      storage_account_rg: 'core-infra-ithc-rg'
      storage_account_name: 'cftappsithc'
      dependsOn: 'sbox_private_dns'
      pipeline_tests: true

    - deployment: 'ithc_apim'
      environment: 'ithc'
      component: 'apim'
      service_connection: 'dcd-cftapps-ithc'
      storage_account_rg: 'core-infra-ithc-rg'
      storage_account_name: 'cftappsithc'
      dependsOn: 'sbox_apim'

    - deployment: 'demo_global'
      environment: 'demo'
      component: 'global'
      service_connection: 'dcd-cftapps-demo'
      storage_account_rg: 'core-infra-demo-rg'
      storage_account_name: 'cftappsdemo'
      dependsOn: 'sbox_global'

    - deployment: 'demo_frontendappgateway'
      environment: 'demo'
      component: 'frontendappgateway'
      service_connection: 'dcd-cftapps-demo'
      storage_account_rg: 'core-infra-demo-rg'
      storage_account_name: 'cftappsdemo'
      dependsOn: 'sbox_frontendappgateway'

    - deployment: 'demo_pubsubappgateway'
      environment: 'demo'
      component: 'pubsubappgateway'
      service_connection: 'dcd-cftapps-demo'
      storage_account_rg: 'core-infra-demo-rg'
      storage_account_name: 'cftappsdemo'
      dependsOn: 'sbox_frontendappgateway'

    - deployment: 'demo_backendappgateway'
      environment: 'demo'
      component: 'backendappgateway'
      service_connection: 'dcd-cftapps-demo'
      storage_account_rg: 'core-infra-demo-rg'
      storage_account_name: 'cftappsdemo'
      dependsOn: 'sbox_backendappgateway'

    - deployment: 'demo_private_dns'
      environment: 'demo'
      component: 'cftapps_private_dns'
      service_connection: 'dcd-cftapps-demo'
      storage_account_rg: 'core-infra-demo-rg'
      storage_account_name: 'cftappsdemo'
      dependsOn: 'sbox_private_dns'

    - deployment: 'demo_apim'
      environment: 'demo'
      component: 'apim'
      service_connection: 'dcd-cftapps-demo'
      storage_account_rg: 'core-infra-demo-rg'
      storage_account_name: 'cftappsdemo'
      dependsOn: 'sbox_apim'
      pipeline_tests: true

    - deployment: 'demo_apim_appgw'
      environment: 'demo'
      component: 'apim-appgw'
      service_connection: 'dcd-cftapps-demo'
      storage_account_rg: 'core-infra-demo-rg'
      storage_account_name: 'cftappsdemo'
      dependsOn: 'sbox_apim_appgw'
      pipeline_tests: false

    - deployment: 'test_frontendappgateway'
      environment: 'test'
      component: 'frontendappgateway'
      service_connection: 'dcd-cftapps-test'
      storage_account_rg: 'core-infra-test-rg'
      storage_account_name: 'cftappstest'
      dependsOn: 'sbox_frontendappgateway'
      pipeline_tests: true

    - deployment: 'perftest_pubsubappgateway'
      environment: 'test'
      component: 'pubsubappgateway'
      service_connection: 'dcd-cftapps-test'
      storage_account_rg: 'core-infra-test-rg'
      storage_account_name: 'cftappstest'
      dependsOn: 'sbox_frontendappgateway'
      pipeline_tests: true

    - deployment: 'test_backendappgateway'
      environment: 'test'
      component: 'backendappgateway'
      service_connection: 'dcd-cftapps-test'
      storage_account_rg: 'core-infra-test-rg'
      storage_account_name: 'cftappstest'
      dependsOn: 'sbox_backendappgateway'
      pipeline_tests: true

    - deployment: 'test_cftapps_private_dns'
      environment: 'test'
      component: 'cftapps_private_dns'
      service_connection: 'dcd-cftapps-test'
      storage_account_rg: 'core-infra-test-rg'
      storage_account_name: 'cftappstest'
      dependsOn: 'sbox_private_dns'
      pipeline_tests: true

    - deployment: 'test_apim'
      environment: 'test'
      component: 'apim'
      service_connection: 'dcd-cftapps-test'
      storage_account_rg: 'core-infra-test-rg'
      storage_account_name: 'cftappstest'
      dependsOn: 'sbox_apim'
      pipeline_tests: true

    - deployment: 'test_apim_appgw'
      environment: 'test'
      component: 'apim-appgw'
      service_connection: 'dcd-cftapps-test'
      storage_account_rg: 'core-infra-test-rg'
      storage_account_name: 'cftappstest'
      dependsOn: 'sbox_apim_appgw'
      pipeline_tests: true

    - deployment: 'perftest_global'
      environment: 'test'
      component: 'global'
      service_connection: 'dcd-cftapps-test'
      storage_account_rg: 'core-infra-test-rg'
      storage_account_name: 'cftappstest'
      pipeline_tests: true
      dependsOn: 'sbox_global'

    - deployment: 'stg_private_dns'
      environment: 'stg'
      component: 'cftapps_private_dns'
      service_connection: 'dcd-cftapps-stg'
      storage_account_rg: 'core-infra-stg-rg'
      storage_account_name: 'cftappsstg'
      dependsOn: 'sbox_private_dns'
      pipeline_tests: true

    - deployment: 'stg_apim'
      environment: 'stg'
      component: 'apim'
      service_connection: 'dcd-cftapps-stg'
      storage_account_rg: 'core-infra-stg-rg'
      storage_account_name: 'cftappsstg'
      dependsOn: 'sbox_apim'
      pipeline_tests: true

    - deployment: 'stg_apim_appgw'
      environment: 'stg'
      component: 'apim-appgw'
      service_connection: 'dcd-cftapps-stg'
      storage_account_rg: 'core-infra-stg-rg'
      storage_account_name: 'cftappsstg'
      dependsOn: 'sbox_apim_appgw'
      pipeline_tests: true

    - deployment: 'stg_frontendappgateway'
      environment: 'stg'
      component: 'frontendappgateway'
      service_connection: 'dcd-cftapps-stg'
      storage_account_rg: 'core-infra-stg-rg'
      storage_account_name: 'cftappsstg'
      dependsOn: 'sbox_frontendappgateway'
      pipeline_tests: true

    - deployment: 'aat_pubsubappgateway'
      environment: 'stg'
      component: 'pubsubappgateway'
      service_connection: 'dcd-cftapps-stg'
      storage_account_rg: 'core-infra-stg-rg'
      storage_account_name: 'cftappsstg'
      dependsOn: 'sbox_frontendappgateway'
      pipeline_tests: true

    - deployment: 'stg_backendappgateway'
      environment: 'stg'
      component: 'backendappgateway'
      service_connection: 'dcd-cftapps-stg'
      storage_account_rg: 'core-infra-stg-rg'
      storage_account_name: 'cftappsstg'
      dependsOn: 'sbox_backendappgateway'
      pipeline_tests: true

    - deployment: 'aat_global'
      environment: 'stg'
      component: 'global'
      service_connection: 'dcd-cftapps-stg'
      storage_account_rg: 'core-infra-stg-rg'
      storage_account_name: 'cftappsstg'
      pipeline_tests: true
      dependsOn: 'sbox_global'

    - deployment: 'prod_shutter_webapp'
      environment: 'prod'
      component: 'shutter_static_webapp'
      service_connection: 'dcd-cftapps-prod'
      storage_account_rg: 'core-infra-prod-rg'
      storage_account_name: 'cftappsprod'
      dependsOn: 'sbox_shutter_webapp'

    - deployment: 'prod_frontendappgateway'
      environment: 'prod'
      component: 'frontendappgateway'
      service_connection: 'dcd-cftapps-prod'
      storage_account_rg: 'core-infra-prod-rg'
      storage_account_name: 'cftappsprod'
      dependsOn: 'sbox_frontendappgateway'
      pipeline_tests: false

    - deployment: 'prod_pubsubappgateway'
      environment: 'prod'
      component: 'pubsubappgateway'
      service_connection: 'dcd-cftapps-prod'
      storage_account_rg: 'core-infra-prod-rg'
      storage_account_name: 'cftappsprod'
      dependsOn: 'sbox_frontendappgateway'
      pipeline_tests: false

    - deployment: 'prod_backendappgateway'
      environment: 'prod'
      component: 'backendappgateway'
      service_connection: 'dcd-cftapps-prod'
      storage_account_rg: 'core-infra-prod-rg'
      storage_account_name: 'cftappsprod'
      dependsOn: 'sbox_backendappgateway'
      pipeline_tests: false

    - deployment: 'prod_private_dns'
      environment: 'prod'
      component: 'cftapps_private_dns'
      service_connection: 'dcd-cftapps-prod'
      storage_account_rg: 'core-infra-prod-rg'
      storage_account_name: 'cftappsprod'
      dependsOn: 'sbox_private_dns'
      pipeline_tests: false

#    - deployment: 'prod_apim'
#      environment: 'prod'
#      component: 'apim'
#      service_connection: 'dcd-cftapps-prod'
#      storage_account_rg: 'core-infra-prod-rg'
#      storage_account_name: 'cftappsprod'
#      dependsOn: 'stg_apim'
#      pipeline_tests: true
#
    - deployment: 'prod_apim_appgw'
      environment: 'prod'
      component: 'apim-appgw'
      service_connection: 'dcd-cftapps-prod'
      storage_account_rg: 'core-infra-prod-rg'
      storage_account_name: 'cftappsprod'
      dependsOn: 'sbox_apim_appgw'
      pipeline_tests: true

    - deployment: 'prod_global'
      environment: 'prod'
      component: 'global'
      service_connection: 'dcd-cftapps-prod'
      storage_account_rg: 'core-infra-prod-rg'
      storage_account_name: 'cftappsprod'
      pipeline_tests: true
      dependsOn: 'sbox_global'

stages:
  - stage: Precheck
    jobs:
      - job: PreCheck_LastCommit
        pool:
          vmImage: ${{ variables.agentPool }}
        timeoutInMinutes: ${{ variables.timeoutInMinutes }}
        steps:
          - checkout: self
            fetchDepth: 1
            persistCredentials: true

          # Consolidated HEAD validation with PR-safe and provider-aware logic.
          - bash: |
              set -euo pipefail

              SRC_BRANCH_REF="${BUILD_SOURCEBRANCH}"
              RUN_SHA="${BUILD_SOURCEVERSION}"
              REPO_URL="$(Build.Repository.Uri)"
              REPO_PROVIDER="${BUILD_REPOSITORY_PROVIDER}"  # 'TfsGit' for Azure Repos, 'GitHub' for GitHub

              echo "Source branch ref: ${SRC_BRANCH_REF}"
              echo "Repository provider: ${REPO_PROVIDER}"
              
              # ---- PR refs: always plan, skip remote validation ----
              if [[ "${SRC_BRANCH_REF}" == refs/pull/* ]]; then
                echo "Pull Request ref detected: ${SRC_BRANCH_REF}. Skipping HEAD validation."
                echo "Setting finalAction=plan (PR safety mode)"
                echo "##vso[task.setvariable variable=finalAction]plan"
                echo "##vso[task.setvariable variable=finalAction;isOutput=true]plan"
                exit 0
              fi

              # ---- Restrict fail-fast to master/main only ----
              if [[ "${SRC_BRANCH_REF}" != "refs/heads/master" && "${SRC_BRANCH_REF}" != "refs/heads/main" ]]; then
                echo "Non-protected branch detected (${SRC_BRANCH_REF}). Skipping HEAD validation."
                echo "Setting finalAction=plan (non-protected branch)"
                echo "##vso[task.setvariable variable=finalAction]plan"
                echo "##vso[task.setvariable variable=finalAction;isOutput=true]plan"
                exit 0
              fi

              BRANCH="${SRC_BRANCH_REF#refs/heads/}"
              if [[ -z "${BRANCH}" ]]; then
                echo "Error: Could not derive branch name from '${SRC_BRANCH_REF}'."
                echo "Setting finalAction=plan (fallback on error)"
                echo "##vso[task.setvariable variable=finalAction]plan"
                exit 0
              fi
              echo "Validating branch: ${BRANCH}"

              # ---- Validate HEAD for Azure Repos or GitHub ----
              if [[ "${REPO_PROVIDER}" == "TfsGit" ]]; then
                # Check if OAuth token is available (required for Azure Repos HEAD validation)
                if [[ -z "${SYSTEM_ACCESSTOKEN:-}" ]]; then
                  echo "##vso[task.logissue type=error]OAuth token missing. Cannot validate HEAD."
                  echo "##vso[task.logissue type=error]To fix: Edit pipeline ‚Üí Job ‚Üí Additional options ‚Üí Enable 'Allow scripts to access the OAuth token'"
                  echo "##vso[task.complete result=Failed;]DONE"
                  exit 1
                fi
                
                echo "OAuth token check passed (required for Azure Repos HEAD validation)"

                # Configure bearer token header for Azure DevOps git over HTTPS
                git config --global http.extraheader "AUTHORIZATION: bearer ${SYSTEM_ACCESSTOKEN}"

                LATEST_SHA=$(git ls-remote "${REPO_URL}" "refs/heads/${BRANCH}" | awk '{print $1}')
                if [[ -z "${LATEST_SHA}" ]]; then
                  echo "Error: Could not resolve branch '${BRANCH}' via ls-remote (Azure Repos)."
                  echo "Setting finalAction=plan (branch resolution failed)"
                  echo "##vso[task.setvariable variable=finalAction]plan"
                  exit 1
                fi

                echo "Latest (HEAD) SHA: ${LATEST_SHA}"
                echo "Current run SHA: ${RUN_SHA}"

                if [[ "${LATEST_SHA}" == "${RUN_SHA}" ]]; then
                  echo "HEAD validation passed (Azure Repos)."
                  echo "Setting finalAction=apply (HEAD validation passed)"
                  echo "##vso[task.setvariable variable=finalAction]apply"
                  echo "##vso[task.setvariable variable=finalAction;isOutput=true]apply"
                else
                  echo "##vso[task.logissue type=error]Commit is not HEAD. Please rerun the pipeline for the latest commit."
                  echo "##vso[task.complete result=Failed;]DONE"
                  exit 1
                fi
                exit 0
              elif [[ "${REPO_PROVIDER}" == "GitHub" ]]; then
                # GitHub HEAD validation - use git fetch to get latest
                echo "GitHub repository detected. Validating HEAD..."
                
                # Fetch the latest from origin to compare
                git fetch origin "${BRANCH}" --depth=1 2>/dev/null || true
                
                # Get the latest commit SHA from origin
                LATEST_SHA=$(git ls-remote origin "refs/heads/${BRANCH}" 2>/dev/null | awk '{print $1}')
                
                # Fallback: try direct remote
                if [[ -z "${LATEST_SHA}" ]]; then
                  LATEST_SHA=$(git rev-parse "origin/${BRANCH}" 2>/dev/null || echo "")
                fi
                
                # Final fallback: use git ls-remote with the repo URL
                if [[ -z "${LATEST_SHA}" ]]; then
                  LATEST_SHA=$(git ls-remote "${REPO_URL}" "refs/heads/${BRANCH}" 2>/dev/null | awk '{print $1}')
                fi

                if [[ -z "${LATEST_SHA}" ]]; then
                  echo "Warning: Could not resolve branch '${BRANCH}' via remote (GitHub). Defaulting to plan mode."
                  echo "Setting finalAction=plan (branch resolution failed)"
                  echo "##vso[task.setvariable variable=finalAction]plan"
                  exit 0
                fi

                echo "Latest (HEAD) SHA: ${LATEST_SHA}"
                echo "Current run SHA: ${RUN_SHA}"

                if [[ "${LATEST_SHA}" == "${RUN_SHA}" ]]; then
                  echo "HEAD validation passed (GitHub)."
                  echo "Setting finalAction=apply (HEAD validation passed)"
                  echo "##vso[task.setvariable variable=finalAction]apply"
                  echo "##vso[task.setvariable variable=finalAction;isOutput=true]apply"
                else
                  echo "##vso[task.logissue type=error]Commit is not HEAD. Please rerun the pipeline for the latest commit."
                  echo "##vso[task.complete result=Failed;]DONE"
                  exit 1
                fi
                exit 0
              fi

              # ---- Other providers: skip HEAD validation, default to plan ----
              echo "Unsupported repository provider detected (${REPO_PROVIDER}). Skipping HEAD validation for ${SRC_BRANCH_REF}."
              echo "Setting finalAction=plan (unsupported repository provider)"
              echo "##vso[task.setvariable variable=finalAction]plan"
              exit 0
            displayName: "Precheck: HEAD validation (master/main only; PR-safe)"
            env:
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)

          # Display finalAction decision in a prominent, easily identifiable step
          - bash: |
              set -euo pipefail
              
              FINAL_ACTION="${finalAction:-NOT_SET}"
              
              echo "##[section]=========================================="
              echo "##[section] FINAL ACTION DECISION"
              echo "##[section]=========================================="
              echo ""
              
              if [[ "${FINAL_ACTION}" == "apply" ]]; then
                echo "##[warning]‚ö†Ô∏è  FINAL ACTION: ${FINAL_ACTION}"
                echo "##[warning]Terraform will RUN PLAN AND APPLY changes"
                echo "##[warning]This means infrastructure changes WILL be applied"
              elif [[ "${FINAL_ACTION}" == "plan" ]]; then
                echo "##[section]‚úì FINAL ACTION: ${FINAL_ACTION}"
                echo "##[section]Terraform will ONLY RUN PLAN (preview mode)"
                echo "##[section]No infrastructure changes will be applied"
              else
                echo "##[error]‚úó FINAL ACTION: ${FINAL_ACTION}"
                echo "##[error]Variable is not set - this may indicate a problem"
              fi
              
              echo ""
              echo "##[section]=========================================="
              echo "##[section]This variable will be passed to terraform-precheck step"
              echo "##[section]=========================================="
            displayName: "üîç VERIFY: finalAction Decision (plan or apply)"
            env:
              finalAction: $(finalAction)

          # Your existing precheck template (receives finalAction)
          - template: steps/terraform-precheck.yaml@cnp-azuredevops-libraries
            parameters:
              keyvaultName: 'infra-vault-nonprod'
              keyvaultSecret: 'azure-devops-sp-token'
              serviceConnection: 'azurerm-sandbox'
              overrideAction: ${{ variables.finalAction }}
              projectName: ${{ variables.businessArea }}
              environment: 'sbox'
              runManualStart: true

  - ${{ each deployment in parameters.environment_components }}:
    - stage: ${{ deployment.deployment }}
      dependsOn: ${{ deployment.dependsOn }}
      jobs:
        - job: TerraformPlanApply
          pool:
            vmImage: ${{ variables.agentPool }}
          timeoutInMinutes: ${{ variables.timeoutInMinutes }}
          steps:
          - template: steps/terraform.yaml@cnp-azuredevops-libraries
            parameters:
              overrideAction: ${{ variables.finalAction }}
              environment: ${{ deployment.environment }}
              component: ${{ deployment.component }}
              serviceConnection: ${{ deployment.service_connection }}
              terraformInitSubscription: ${{ variables.terraformInitSubscription }}
              product: ${{ variables.product }}
              publishPlanResults: ${{ variables.publishPlanResults }}
          
          # Handle ACR cleanup errors gracefully
          # This step runs after terraform to catch and handle transient ACR cleanup errors
          # that may occur during the terraform template's cleanup process
          - task: AzureCLI@2
            displayName: 'Handle ACR cleanup errors (if any)'
            condition: always()  # Run even if previous step failed
            continueOnError: true  # Don't fail the pipeline on cleanup errors
            inputs:
              azureSubscription: ${{ deployment.service_connection }}
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Checking for any ACR cleanup issues..."
                echo "Note: Transient ACR cleanup errors (500 status codes) are expected and non-blocking."
                echo "If cleanup failed in the previous step, it will be retried in the next pipeline run."
                echo "This step ensures the pipeline continues even if cleanup encounters transient Azure errors."

        - job: PipelineTests
          pool:
            vmImage: ${{ variables.agentPool }}
          timeoutInMinutes: ${{ variables.timeoutInMinutes }}
          dependsOn: TerraformPlanApply
          condition: and(succeeded(), eq(variables['isMain'], true), eq('${{ deployment.pipeline_tests }}', 'true'))
          steps:
            - template: steps/pipeline-tests-jest.yaml@cnp-azuredevops-libraries
              parameters:
                workingDirectory: $(Pipeline.Workspace)/s/azure-platform-terraform/scripts
                junit_output_dir: $(Pipeline.Workspace)/s/azure-platform-terraform/environments/${{ deployment.environment }}/junit
                environment: ${{ deployment.environment }}
                product: ${{ variables.product }}
                test_title: '${{ deployment.environment }}_${{ deployment.component }}'
                ${{ if eq(deployment.component, 'apim') }}:
                  test_pattern: apim.test.ts
                ${{ else }}:
                  test_pattern: pipeline.test.ts

  - stage: Analyse_plans
    displayName: "Analyse terraform plan"
    condition: and(eq('${{ variables.finalAction }}', 'Plan'), succeededOrFailed())
    dependsOn:
      - ${{ each component in parameters.environment_components }}:
        - ${{ if eq(component.environment, 'stg') }}:
          - aat_global
        - ${{ if eq(component.environment, 'test') }}:
          - perftest_global
        - ${{ if and(ne(component.environment, 'stg'), ne(component.environment, 'test')) }}:
          - ${{ component.environment }}_global
    jobs:
      - job: AnalysePlans
        steps:
          - template: steps/terraform-plan-analyse.yaml@cnp-azuredevops-libraries
            parameters:
              serviceConnection: DTS-CFTPTL-INTSVC
